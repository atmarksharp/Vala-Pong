/* engine.c generated by valac 0.12.0, the Vala compiler
 * generated from engine.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gee.h>
#include <GL/gl.h>
#include <SDL.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>


#define DARKCORE_TYPE_ENGINE (darkcore_engine_get_type ())
#define DARKCORE_ENGINE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DARKCORE_TYPE_ENGINE, DarkcoreEngine))
#define DARKCORE_ENGINE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), DARKCORE_TYPE_ENGINE, DarkcoreEngineClass))
#define DARKCORE_IS_ENGINE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DARKCORE_TYPE_ENGINE))
#define DARKCORE_IS_ENGINE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), DARKCORE_TYPE_ENGINE))
#define DARKCORE_ENGINE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), DARKCORE_TYPE_ENGINE, DarkcoreEngineClass))

typedef struct _DarkcoreEngine DarkcoreEngine;
typedef struct _DarkcoreEngineClass DarkcoreEngineClass;
typedef struct _DarkcoreEnginePrivate DarkcoreEnginePrivate;

#define DARKCORE_TYPE_TEXTURE (darkcore_texture_get_type ())
#define DARKCORE_TEXTURE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DARKCORE_TYPE_TEXTURE, DarkcoreTexture))
#define DARKCORE_TEXTURE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), DARKCORE_TYPE_TEXTURE, DarkcoreTextureClass))
#define DARKCORE_IS_TEXTURE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DARKCORE_TYPE_TEXTURE))
#define DARKCORE_IS_TEXTURE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), DARKCORE_TYPE_TEXTURE))
#define DARKCORE_TEXTURE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), DARKCORE_TYPE_TEXTURE, DarkcoreTextureClass))

typedef struct _DarkcoreTexture DarkcoreTexture;
typedef struct _DarkcoreTextureClass DarkcoreTextureClass;

#define DARKCORE_TYPE_SPRITE (darkcore_sprite_get_type ())
#define DARKCORE_SPRITE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DARKCORE_TYPE_SPRITE, DarkcoreSprite))
#define DARKCORE_SPRITE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), DARKCORE_TYPE_SPRITE, DarkcoreSpriteClass))
#define DARKCORE_IS_SPRITE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DARKCORE_TYPE_SPRITE))
#define DARKCORE_IS_SPRITE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), DARKCORE_TYPE_SPRITE))
#define DARKCORE_SPRITE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), DARKCORE_TYPE_SPRITE, DarkcoreSpriteClass))

typedef struct _DarkcoreSprite DarkcoreSprite;
typedef struct _DarkcoreSpriteClass DarkcoreSpriteClass;

#define DARKCORE_TYPE_KEY_STATE (darkcore_key_state_get_type ())
#define DARKCORE_KEY_STATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DARKCORE_TYPE_KEY_STATE, DarkcoreKeyState))
#define DARKCORE_KEY_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), DARKCORE_TYPE_KEY_STATE, DarkcoreKeyStateClass))
#define DARKCORE_IS_KEY_STATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DARKCORE_TYPE_KEY_STATE))
#define DARKCORE_IS_KEY_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), DARKCORE_TYPE_KEY_STATE))
#define DARKCORE_KEY_STATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), DARKCORE_TYPE_KEY_STATE, DarkcoreKeyStateClass))

typedef struct _DarkcoreKeyState DarkcoreKeyState;
typedef struct _DarkcoreKeyStateClass DarkcoreKeyStateClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _DarkcoreSpritePrivate DarkcoreSpritePrivate;

typedef void (*DarkcoreEngineDelegateType) (DarkcoreEngine* world, void* user_data);
struct _DarkcoreEngine {
	GObject parent_instance;
	DarkcoreEnginePrivate * priv;
	DarkcoreEngineDelegateType on_loop_events_00;
	gpointer on_loop_events_00_target;
	GDestroyNotify on_loop_events_00_target_destroy_notify;
	DarkcoreEngineDelegateType on_loop_events_01;
	gpointer on_loop_events_01_target;
	GDestroyNotify on_loop_events_01_target_destroy_notify;
	DarkcoreEngineDelegateType on_loop_events_02;
	gpointer on_loop_events_02_target;
	GDestroyNotify on_loop_events_02_target_destroy_notify;
	DarkcoreEngineDelegateType on_loop_events_03;
	gpointer on_loop_events_03_target;
	GDestroyNotify on_loop_events_03_target_destroy_notify;
	DarkcoreEngineDelegateType on_loop_events_04;
	gpointer on_loop_events_04_target;
	GDestroyNotify on_loop_events_04_target_destroy_notify;
	GeeArrayList* textures;
	GeeArrayList* sprites;
	GLuint tids[32];
	DarkcoreKeyState* keys;
	DarkcoreSprite* player;
	SDL_Surface* screen;
	gboolean done;
	gint width;
	gint height;
};

struct _DarkcoreEngineClass {
	GObjectClass parent_class;
};

typedef void (*DarkcoreSpriteDelegateType) (DarkcoreEngine* world, DarkcoreSprite* sprite, void* user_data);
struct _DarkcoreSprite {
	GObject parent_instance;
	DarkcoreSpritePrivate * priv;
	DarkcoreSpriteDelegateType on_key_press;
	gpointer on_key_press_target;
	GDestroyNotify on_key_press_target_destroy_notify;
	DarkcoreSpriteDelegateType on_render;
	gpointer on_render_target;
	GDestroyNotify on_render_target_destroy_notify;
	DarkcoreEngine* world;
};

struct _DarkcoreSpriteClass {
	GObjectClass parent_class;
};


static gpointer darkcore_engine_parent_class = NULL;

GType darkcore_engine_get_type (void) G_GNUC_CONST;
GType darkcore_texture_get_type (void) G_GNUC_CONST;
GType darkcore_sprite_get_type (void) G_GNUC_CONST;
GType darkcore_key_state_get_type (void) G_GNUC_CONST;
enum  {
	DARKCORE_ENGINE_DUMMY_PROPERTY
};
DarkcoreEngine* darkcore_engine_new (gint width, gint height);
DarkcoreEngine* darkcore_engine_construct (GType object_type, gint width, gint height);
DarkcoreKeyState* darkcore_key_state_new (void);
DarkcoreKeyState* darkcore_key_state_construct (GType object_type);
void darkcore_engine_init_video (DarkcoreEngine* self);
gint darkcore_engine_add_event_on_loop (DarkcoreEngine* self, DarkcoreEngineDelegateType fn, void* fn_target);
void darkcore_engine_process_events (DarkcoreEngine* self);
void darkcore_engine_on_keyboard_event (DarkcoreEngine* self, SDL_KeyboardEvent* event, gboolean isdown);
void darkcore_key_state_set_space (DarkcoreKeyState* self, gboolean value);
void darkcore_key_state_set_up (DarkcoreKeyState* self, gboolean value);
void darkcore_key_state_set_down (DarkcoreKeyState* self, gboolean value);
void darkcore_key_state_set_left (DarkcoreKeyState* self, gboolean value);
void darkcore_key_state_set_right (DarkcoreKeyState* self, gboolean value);
gboolean darkcore_engine_is_alt_enter (SDL_keysym* key);
void darkcore_engine_draw (DarkcoreEngine* self);
void darkcore_sprite_fire_render (DarkcoreSprite* self, DarkcoreSpriteDelegateType render, void* render_target, DarkcoreEngine* world, DarkcoreSprite* sprite);
void darkcore_sprite_render (DarkcoreSprite* self);
void darkcore_engine_run (DarkcoreEngine* self);
void darkcore_engine_render (DarkcoreEngine* self);
void darkcore_sprite_fire_key_press (DarkcoreSprite* self, DarkcoreSpriteDelegateType key_press, void* key_press_target, DarkcoreEngine* world, DarkcoreSprite* sprite);
DarkcoreTexture* darkcore_engine_getTexture (DarkcoreEngine* self, gint index);
gint darkcore_engine_addTexture (DarkcoreEngine* self, const gchar* filename);
DarkcoreTexture* darkcore_texture_new_from_file (const gchar* filename, DarkcoreEngine* world);
DarkcoreTexture* darkcore_texture_construct_from_file (GType object_type, const gchar* filename, DarkcoreEngine* world);
static void darkcore_engine_finalize (GObject* obj);


DarkcoreEngine* darkcore_engine_construct (GType object_type, gint width, gint height) {
	DarkcoreEngine * self = NULL;
	GeeArrayList* _tmp0_ = NULL;
	GeeArrayList* _tmp1_ = NULL;
	DarkcoreKeyState* _tmp2_ = NULL;
	self = (DarkcoreEngine*) g_object_new (object_type, NULL);
	SDL_Init ((guint32) (SDL_INIT_VIDEO | SDL_INIT_AUDIO));
	_tmp0_ = gee_array_list_new (DARKCORE_TYPE_TEXTURE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	_g_object_unref0 (self->textures);
	self->textures = _tmp0_;
	_tmp1_ = gee_array_list_new (DARKCORE_TYPE_SPRITE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL);
	_g_object_unref0 (self->sprites);
	self->sprites = _tmp1_;
	_tmp2_ = darkcore_key_state_new ();
	_g_object_unref0 (self->keys);
	self->keys = _tmp2_;
	self->width = width;
	self->height = height;
	darkcore_engine_init_video (self);
	return self;
}


DarkcoreEngine* darkcore_engine_new (gint width, gint height) {
	return darkcore_engine_construct (DARKCORE_TYPE_ENGINE, width, height);
}


gint darkcore_engine_add_event_on_loop (DarkcoreEngine* self, DarkcoreEngineDelegateType fn, void* fn_target) {
	gint result = 0;
	g_return_val_if_fail (self != NULL, 0);
	if (self->on_loop_events_00 == NULL) {
		DarkcoreEngineDelegateType _tmp0_;
		_tmp0_ = fn;
		(self->on_loop_events_00_target_destroy_notify == NULL) ? NULL : (self->on_loop_events_00_target_destroy_notify (self->on_loop_events_00_target), NULL);
		self->on_loop_events_00 = NULL;
		self->on_loop_events_00_target = NULL;
		self->on_loop_events_00_target_destroy_notify = NULL;
		self->on_loop_events_00 = _tmp0_;
		self->on_loop_events_00_target = fn_target;
		self->on_loop_events_00_target_destroy_notify = NULL;
		result = 0;
		return result;
	}
	if (self->on_loop_events_01 == NULL) {
		DarkcoreEngineDelegateType _tmp1_;
		_tmp1_ = fn;
		(self->on_loop_events_01_target_destroy_notify == NULL) ? NULL : (self->on_loop_events_01_target_destroy_notify (self->on_loop_events_01_target), NULL);
		self->on_loop_events_01 = NULL;
		self->on_loop_events_01_target = NULL;
		self->on_loop_events_01_target_destroy_notify = NULL;
		self->on_loop_events_01 = _tmp1_;
		self->on_loop_events_01_target = fn_target;
		self->on_loop_events_01_target_destroy_notify = NULL;
		result = 1;
		return result;
	}
	if (self->on_loop_events_02 == NULL) {
		DarkcoreEngineDelegateType _tmp2_;
		_tmp2_ = fn;
		(self->on_loop_events_02_target_destroy_notify == NULL) ? NULL : (self->on_loop_events_02_target_destroy_notify (self->on_loop_events_02_target), NULL);
		self->on_loop_events_02 = NULL;
		self->on_loop_events_02_target = NULL;
		self->on_loop_events_02_target_destroy_notify = NULL;
		self->on_loop_events_02 = _tmp2_;
		self->on_loop_events_02_target = fn_target;
		self->on_loop_events_02_target_destroy_notify = NULL;
		result = 2;
		return result;
	}
	if (self->on_loop_events_03 == NULL) {
		DarkcoreEngineDelegateType _tmp3_;
		_tmp3_ = fn;
		(self->on_loop_events_03_target_destroy_notify == NULL) ? NULL : (self->on_loop_events_03_target_destroy_notify (self->on_loop_events_03_target), NULL);
		self->on_loop_events_03 = NULL;
		self->on_loop_events_03_target = NULL;
		self->on_loop_events_03_target_destroy_notify = NULL;
		self->on_loop_events_03 = _tmp3_;
		self->on_loop_events_03_target = fn_target;
		self->on_loop_events_03_target_destroy_notify = NULL;
		result = 3;
		return result;
	}
	if (self->on_loop_events_04 == NULL) {
		DarkcoreEngineDelegateType _tmp4_;
		_tmp4_ = fn;
		(self->on_loop_events_04_target_destroy_notify == NULL) ? NULL : (self->on_loop_events_04_target_destroy_notify (self->on_loop_events_04_target), NULL);
		self->on_loop_events_04 = NULL;
		self->on_loop_events_04_target = NULL;
		self->on_loop_events_04_target_destroy_notify = NULL;
		self->on_loop_events_04 = _tmp4_;
		self->on_loop_events_04_target = fn_target;
		self->on_loop_events_04_target_destroy_notify = NULL;
		result = 4;
		return result;
	}
	result = -1;
	return result;
}


void darkcore_engine_process_events (DarkcoreEngine* self) {
	SDL_Event event = {0};
	g_return_if_fail (self != NULL);
	memset (&event, 0, sizeof (SDL_Event));
	while (TRUE) {
		gint _tmp0_;
		_tmp0_ = SDL_PollEvent (&event);
		if (!(_tmp0_ == 1)) {
			break;
		}
		switch (event.type) {
			case SDL_QUIT:
			{
				self->done = TRUE;
				break;
			}
			case SDL_KEYDOWN:
			{
				darkcore_engine_on_keyboard_event (self, &event.key, TRUE);
				break;
			}
			case SDL_KEYUP:
			{
				darkcore_engine_on_keyboard_event (self, &event.key, FALSE);
				break;
			}
			default:
			break;
		}
	}
}


void darkcore_engine_on_keyboard_event (DarkcoreEngine* self, SDL_KeyboardEvent* event, gboolean isdown) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	switch ((*event).keysym.sym) {
		case SDLK_SPACE:
		{
			darkcore_key_state_set_space (self->keys, isdown);
			break;
		}
		case SDLK_UP:
		{
			darkcore_key_state_set_up (self->keys, isdown);
			break;
		}
		case SDLK_DOWN:
		{
			darkcore_key_state_set_down (self->keys, isdown);
			break;
		}
		case SDLK_LEFT:
		{
			darkcore_key_state_set_left (self->keys, isdown);
			break;
		}
		case SDLK_RIGHT:
		{
			darkcore_key_state_set_right (self->keys, isdown);
			break;
		}
		case SDLK_ESCAPE:
		{
			self->done = TRUE;
			break;
		}
		default:
		break;
	}
	if (isdown) {
		gboolean _tmp1_;
		_tmp1_ = darkcore_engine_is_alt_enter (&(*event).keysym);
		_tmp0_ = _tmp1_;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		SDL_WM_ToggleFullScreen (self->screen);
	}
}


gboolean darkcore_engine_is_alt_enter (SDL_keysym* key) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	if (((*key).mod & KMOD_LALT) != 0) {
		gboolean _tmp1_ = FALSE;
		if ((*key).sym == SDLK_RETURN) {
			_tmp1_ = TRUE;
		} else {
			_tmp1_ = (*key).sym == SDLK_KP_ENTER;
		}
		_tmp0_ = _tmp1_;
	} else {
		_tmp0_ = FALSE;
	}
	result = _tmp0_;
	return result;
}


void darkcore_engine_init_video (DarkcoreEngine* self) {
	SDL_VideoInfo* _tmp0_ = NULL;
	guchar bpp;
	guint32 video_flags;
	SDL_Surface* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = SDL_GetVideoInfo ();
	bpp = _tmp0_->vfmt->BitsPerPixel;
	SDL_GL_SetAttribute (SDL_GL_RED_SIZE, 5);
	SDL_GL_SetAttribute (SDL_GL_GREEN_SIZE, 5);
	SDL_GL_SetAttribute (SDL_GL_BLUE_SIZE, 5);
	SDL_GL_SetAttribute (SDL_GL_DEPTH_SIZE, 16);
	SDL_GL_SetAttribute (SDL_GL_DOUBLEBUFFER, 1);
	video_flags = (guint32) SDL_OPENGL;
	_tmp1_ = SDL_SetVideoMode (self->width, self->height, (gint) bpp, video_flags);
	self->screen = _tmp1_;
	if (self->screen == NULL) {
		fprintf (stderr, "Could not set video mode.\n");
	}
	SDL_WM_SetCaption ("TODO: Allow Title", "");
	glShadeModel (GL_SMOOTH);
	glCullFace (GL_BACK);
	glFrontFace (GL_CCW);
	glEnable (GL_CULL_FACE);
	glClearColor ((GLclampf) 0, (GLclampf) 0, (GLclampf) 0, (GLclampf) 0);
	glViewport ((GLint) 0, (GLint) 0, (GLsizei) self->screen->w, (GLsizei) self->screen->h);
	glMatrixMode (GL_PROJECTION);
	glLoadIdentity ();
	glOrtho ((GLdouble) 0, (GLdouble) self->screen->w, (GLdouble) 0, (GLdouble) self->screen->h, (GLdouble) (-100), (GLdouble) 100);
	glGenTextures ((GLsizei) 32, self->tids);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void darkcore_engine_draw (DarkcoreEngine* self) {
	g_return_if_fail (self != NULL);
	glClear ((GLbitfield) (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT));
	glMatrixMode (GL_MODELVIEW);
	glLoadIdentity ();
	glTranslated ((GLdouble) 0, (GLdouble) 0, (GLdouble) (-10));
	{
		GeeArrayList* _tmp0_;
		GeeArrayList* _sprite_list;
		gint _tmp1_;
		gint _sprite_size;
		gint _sprite_index;
		_tmp0_ = _g_object_ref0 (self->sprites);
		_sprite_list = _tmp0_;
		_tmp1_ = gee_collection_get_size ((GeeCollection*) _sprite_list);
		_sprite_size = _tmp1_;
		_sprite_index = -1;
		while (TRUE) {
			gpointer _tmp2_ = NULL;
			DarkcoreSprite* sprite;
			_sprite_index = _sprite_index + 1;
			if (!(_sprite_index < _sprite_size)) {
				break;
			}
			_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) _sprite_list, _sprite_index);
			sprite = (DarkcoreSprite*) _tmp2_;
			if (sprite->on_render != NULL) {
				darkcore_sprite_fire_render (sprite, sprite->on_render, sprite->on_render_target, self, sprite);
			}
			darkcore_sprite_render (sprite);
			_g_object_unref0 (sprite);
		}
		_g_object_unref0 (_sprite_list);
	}
	SDL_GL_SwapBuffers ();
}


void darkcore_engine_run (DarkcoreEngine* self) {
	g_return_if_fail (self != NULL);
	darkcore_engine_render (self);
	SDL_Quit ();
}


void darkcore_engine_render (DarkcoreEngine* self) {
	guint32 _tmp0_;
	guint32 old_time;
	gint fps;
	gint minticks;
	g_return_if_fail (self != NULL);
	_tmp0_ = SDL_GetTicks ();
	old_time = _tmp0_;
	fps = 0;
	minticks = 1000 / 60;
	while (TRUE) {
		guint32 _tmp1_;
		guint32 new_time;
		guint32 time_since_last_frame;
		if (!(!self->done)) {
			break;
		}
		_tmp1_ = SDL_GetTicks ();
		new_time = _tmp1_;
		time_since_last_frame = new_time - old_time;
		darkcore_engine_process_events (self);
		{
			GeeArrayList* _tmp2_;
			GeeArrayList* _sprite_list;
			gint _tmp3_;
			gint _sprite_size;
			gint _sprite_index;
			_tmp2_ = _g_object_ref0 (self->sprites);
			_sprite_list = _tmp2_;
			_tmp3_ = gee_collection_get_size ((GeeCollection*) _sprite_list);
			_sprite_size = _tmp3_;
			_sprite_index = -1;
			while (TRUE) {
				gpointer _tmp4_ = NULL;
				DarkcoreSprite* sprite;
				_sprite_index = _sprite_index + 1;
				if (!(_sprite_index < _sprite_size)) {
					break;
				}
				_tmp4_ = gee_abstract_list_get ((GeeAbstractList*) _sprite_list, _sprite_index);
				sprite = (DarkcoreSprite*) _tmp4_;
				if (sprite->on_key_press != NULL) {
					darkcore_sprite_fire_key_press (sprite, sprite->on_key_press, sprite->on_key_press_target, self, sprite);
				}
				_g_object_unref0 (sprite);
			}
			_g_object_unref0 (_sprite_list);
		}
		darkcore_engine_draw (self);
		fps++;
		SDL_Delay ((guint32) minticks);
		if (time_since_last_frame > 1000) {
			g_print ("FPS: %i\n", fps);
			old_time = new_time;
			fps = 0;
		}
	}
}


DarkcoreTexture* darkcore_engine_getTexture (DarkcoreEngine* self, gint index) {
	DarkcoreTexture* result = NULL;
	DarkcoreTexture* texture;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	texture = NULL;
	_tmp0_ = gee_collection_get_size ((GeeCollection*) self->textures);
	if (index < _tmp0_) {
		gpointer _tmp1_ = NULL;
		DarkcoreTexture* _tmp2_;
		_tmp1_ = gee_abstract_list_get ((GeeAbstractList*) self->textures, index);
		_tmp2_ = _g_object_ref0 (_tmp1_);
		_g_object_unref0 (texture);
		texture = _tmp2_;
	}
	result = texture;
	return result;
}


gint darkcore_engine_addTexture (DarkcoreEngine* self, const gchar* filename) {
	gint result = 0;
	DarkcoreTexture* _tmp0_ = NULL;
	gint _tmp1_;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (filename != NULL, 0);
	_tmp0_ = darkcore_texture_new_from_file (filename, self);
	gee_abstract_collection_add ((GeeAbstractCollection*) self->textures, _tmp0_);
	_tmp1_ = gee_collection_get_size ((GeeCollection*) self->textures);
	result = _tmp1_ - 1;
	return result;
}


static void darkcore_engine_class_init (DarkcoreEngineClass * klass) {
	darkcore_engine_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = darkcore_engine_finalize;
}


static void darkcore_engine_instance_init (DarkcoreEngine * self) {
}


static void darkcore_engine_finalize (GObject* obj) {
	DarkcoreEngine * self;
	self = DARKCORE_ENGINE (obj);
	(self->on_loop_events_00_target_destroy_notify == NULL) ? NULL : (self->on_loop_events_00_target_destroy_notify (self->on_loop_events_00_target), NULL);
	self->on_loop_events_00 = NULL;
	self->on_loop_events_00_target = NULL;
	self->on_loop_events_00_target_destroy_notify = NULL;
	(self->on_loop_events_01_target_destroy_notify == NULL) ? NULL : (self->on_loop_events_01_target_destroy_notify (self->on_loop_events_01_target), NULL);
	self->on_loop_events_01 = NULL;
	self->on_loop_events_01_target = NULL;
	self->on_loop_events_01_target_destroy_notify = NULL;
	(self->on_loop_events_02_target_destroy_notify == NULL) ? NULL : (self->on_loop_events_02_target_destroy_notify (self->on_loop_events_02_target), NULL);
	self->on_loop_events_02 = NULL;
	self->on_loop_events_02_target = NULL;
	self->on_loop_events_02_target_destroy_notify = NULL;
	(self->on_loop_events_03_target_destroy_notify == NULL) ? NULL : (self->on_loop_events_03_target_destroy_notify (self->on_loop_events_03_target), NULL);
	self->on_loop_events_03 = NULL;
	self->on_loop_events_03_target = NULL;
	self->on_loop_events_03_target_destroy_notify = NULL;
	(self->on_loop_events_04_target_destroy_notify == NULL) ? NULL : (self->on_loop_events_04_target_destroy_notify (self->on_loop_events_04_target), NULL);
	self->on_loop_events_04 = NULL;
	self->on_loop_events_04_target = NULL;
	self->on_loop_events_04_target_destroy_notify = NULL;
	_g_object_unref0 (self->textures);
	_g_object_unref0 (self->sprites);
	_g_object_unref0 (self->keys);
	_g_object_unref0 (self->player);
	G_OBJECT_CLASS (darkcore_engine_parent_class)->finalize (obj);
}


GType darkcore_engine_get_type (void) {
	static volatile gsize darkcore_engine_type_id__volatile = 0;
	if (g_once_init_enter (&darkcore_engine_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (DarkcoreEngineClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) darkcore_engine_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (DarkcoreEngine), 0, (GInstanceInitFunc) darkcore_engine_instance_init, NULL };
		GType darkcore_engine_type_id;
		darkcore_engine_type_id = g_type_register_static (G_TYPE_OBJECT, "DarkcoreEngine", &g_define_type_info, 0);
		g_once_init_leave (&darkcore_engine_type_id__volatile, darkcore_engine_type_id);
	}
	return darkcore_engine_type_id__volatile;
}



