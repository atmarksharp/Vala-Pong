/* vector.c generated by valac 0.12.0, the Vala compiler
 * generated from vector.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gsl/gsl_vector_double.h>
#include <float.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>

typedef gsl_vector DarkcoreVector;
#define _g_free0(var) (var = (g_free (var), NULL))



DarkcoreVector* darkcore_vector_new (gsize n);
DarkcoreVector* darkcore_vector_new (gsize n);
DarkcoreVector* darkcore_vector_new_copy (gsl_vector* vector);
DarkcoreVector* darkcore_vector_new_copy (gsl_vector* vector);
gint darkcore_vector_mul_scalar (DarkcoreVector* self, gdouble val);
gint darkcore_vector_div_scalar (DarkcoreVector* self, gdouble val);
gint darkcore_vector_add_scalar (DarkcoreVector* self, gdouble val);
gint darkcore_vector_sub_scalar (DarkcoreVector* self, gdouble val);
gdouble darkcore_vector_dot (DarkcoreVector* self, gsl_vector* vector);
gdouble darkcore_vector_length (DarkcoreVector* self);
gchar* darkcore_vector_to_string (DarkcoreVector* self);


DarkcoreVector* darkcore_vector_new (gsize n) {
	DarkcoreVector* self;
	self = (DarkcoreVector*) gsl_vector_alloc (n);
	return self;
}


DarkcoreVector* darkcore_vector_new_copy (gsl_vector* vector) {
	DarkcoreVector* self;
	g_return_val_if_fail (vector != NULL, NULL);
	self = (DarkcoreVector*) gsl_vector_alloc (vector->size);
	gsl_vector_memcpy ((gsl_vector*) self, vector);
	return self;
}


gint darkcore_vector_mul_scalar (DarkcoreVector* self, gdouble val) {
	gint result = 0;
	g_return_val_if_fail (self != NULL, 0);
	gsl_vector_scale ((gsl_vector*) self, val);
	result = 0;
	return result;
}


gint darkcore_vector_div_scalar (DarkcoreVector* self, gdouble val) {
	gint result = 0;
	g_return_val_if_fail (self != NULL, 0);
	gsl_vector_scale ((gsl_vector*) self, 1 / val);
	result = 0;
	return result;
}


gint darkcore_vector_add_scalar (DarkcoreVector* self, gdouble val) {
	gint result = 0;
	g_return_val_if_fail (self != NULL, 0);
	gsl_vector_add_constant ((gsl_vector*) self, val);
	result = 0;
	return result;
}


gint darkcore_vector_sub_scalar (DarkcoreVector* self, gdouble val) {
	gint result = 0;
	g_return_val_if_fail (self != NULL, 0);
	gsl_vector_add_constant ((gsl_vector*) self, -val);
	result = 0;
	return result;
}


gdouble darkcore_vector_dot (DarkcoreVector* self, gsl_vector* vector) {
	gdouble result = 0.0;
	gsize length;
	gdouble _result_;
	g_return_val_if_fail (self != NULL, 0.0);
	g_return_val_if_fail (vector != NULL, 0.0);
	length = ((gsl_vector*) self)->size;
	_result_ = 0.00;
	{
		gint index;
		index = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				gdouble _tmp1_;
				gdouble _tmp2_;
				if (!_tmp0_) {
					index++;
				}
				_tmp0_ = FALSE;
				if (!(index < length)) {
					break;
				}
				_tmp1_ = gsl_vector_get ((gsl_vector*) self, (gsize) index);
				_tmp2_ = gsl_vector_get (vector, (gsize) index);
				_result_ = _result_ + (_tmp1_ * _tmp2_);
			}
		}
	}
	result = _result_;
	return result;
}


gdouble darkcore_vector_length (DarkcoreVector* self) {
	gdouble result = 0.0;
	gsize length;
	gdouble _result_;
	gdouble _tmp3_;
	g_return_val_if_fail (self != NULL, 0.0);
	length = ((gsl_vector*) self)->size;
	_result_ = 0.00;
	{
		gint index;
		index = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				gdouble _tmp1_;
				gdouble _tmp2_;
				if (!_tmp0_) {
					index++;
				}
				_tmp0_ = FALSE;
				if (!(index < length)) {
					break;
				}
				_tmp1_ = gsl_vector_get ((gsl_vector*) self, (gsize) index);
				_tmp2_ = gsl_vector_get ((gsl_vector*) self, (gsize) index);
				_result_ = _result_ + (_tmp1_ * _tmp2_);
			}
		}
	}
	_tmp3_ = sqrt (_result_);
	result = _tmp3_;
	return result;
}


static gchar* double_to_string (gdouble self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	gint _tmp1__length1;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	gchar* _tmp4_;
	_tmp0_ = g_new0 (gchar, G_ASCII_DTOSTR_BUF_SIZE);
	_tmp1_ = _tmp0_;
	_tmp1__length1 = G_ASCII_DTOSTR_BUF_SIZE;
	_tmp2_ = g_ascii_dtostr (_tmp1_, G_ASCII_DTOSTR_BUF_SIZE, self);
	_tmp3_ = g_strdup (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp1_ = (g_free (_tmp1_), NULL);
	result = _tmp4_;
	return result;
}


gchar* darkcore_vector_to_string (DarkcoreVector* self) {
	gchar* result = NULL;
	gsize length;
	gchar* _tmp0_;
	gchar* _result_;
	gchar* _tmp7_;
	g_return_val_if_fail (self != NULL, NULL);
	length = ((gsl_vector*) self)->size;
	_tmp0_ = g_strdup ("(");
	_result_ = _tmp0_;
	{
		gint index;
		index = 0;
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				gdouble _tmp3_;
				gchar* _tmp4_ = NULL;
				gchar* _tmp5_;
				gchar* _tmp6_;
				if (!_tmp1_) {
					index++;
				}
				_tmp1_ = FALSE;
				if (!(index < length)) {
					break;
				}
				if (index != 0) {
					gchar* _tmp2_;
					_tmp2_ = g_strconcat (_result_, ", ", NULL);
					_g_free0 (_result_);
					_result_ = _tmp2_;
				}
				_tmp3_ = gsl_vector_get ((gsl_vector*) self, (gsize) index);
				_tmp4_ = double_to_string (_tmp3_);
				_tmp5_ = _tmp4_;
				_tmp6_ = g_strconcat (_result_, _tmp5_, NULL);
				_g_free0 (_result_);
				_result_ = _tmp6_;
				_g_free0 (_tmp5_);
			}
		}
	}
	_tmp7_ = g_strconcat (_result_, ")", NULL);
	_g_free0 (_result_);
	_result_ = _tmp7_;
	result = _result_;
	return result;
}



