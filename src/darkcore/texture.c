/* texture.c generated by valac 0.12.0, the Vala compiler
 * generated from texture.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <SDL.h>
#include <GL/gl.h>
#include <stdlib.h>
#include <string.h>
#include <SDL_image.h>
#include <gee.h>


#define DARKCORE_TYPE_TEXTURE (darkcore_texture_get_type ())
#define DARKCORE_TEXTURE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DARKCORE_TYPE_TEXTURE, DarkcoreTexture))
#define DARKCORE_TEXTURE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), DARKCORE_TYPE_TEXTURE, DarkcoreTextureClass))
#define DARKCORE_IS_TEXTURE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DARKCORE_TYPE_TEXTURE))
#define DARKCORE_IS_TEXTURE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), DARKCORE_TYPE_TEXTURE))
#define DARKCORE_TEXTURE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), DARKCORE_TYPE_TEXTURE, DarkcoreTextureClass))

typedef struct _DarkcoreTexture DarkcoreTexture;
typedef struct _DarkcoreTextureClass DarkcoreTextureClass;
typedef struct _DarkcoreTexturePrivate DarkcoreTexturePrivate;

#define DARKCORE_TYPE_ENGINE (darkcore_engine_get_type ())
#define DARKCORE_ENGINE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DARKCORE_TYPE_ENGINE, DarkcoreEngine))
#define DARKCORE_ENGINE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), DARKCORE_TYPE_ENGINE, DarkcoreEngineClass))
#define DARKCORE_IS_ENGINE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DARKCORE_TYPE_ENGINE))
#define DARKCORE_IS_ENGINE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), DARKCORE_TYPE_ENGINE))
#define DARKCORE_ENGINE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), DARKCORE_TYPE_ENGINE, DarkcoreEngineClass))

typedef struct _DarkcoreEngine DarkcoreEngine;
typedef struct _DarkcoreEngineClass DarkcoreEngineClass;
typedef struct _DarkcoreEnginePrivate DarkcoreEnginePrivate;

#define DARKCORE_TYPE_SPRITE (darkcore_sprite_get_type ())
#define DARKCORE_SPRITE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DARKCORE_TYPE_SPRITE, DarkcoreSprite))
#define DARKCORE_SPRITE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), DARKCORE_TYPE_SPRITE, DarkcoreSpriteClass))
#define DARKCORE_IS_SPRITE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DARKCORE_TYPE_SPRITE))
#define DARKCORE_IS_SPRITE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), DARKCORE_TYPE_SPRITE))
#define DARKCORE_SPRITE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), DARKCORE_TYPE_SPRITE, DarkcoreSpriteClass))

typedef struct _DarkcoreSprite DarkcoreSprite;
typedef struct _DarkcoreSpriteClass DarkcoreSpriteClass;

#define DARKCORE_TYPE_KEY_STATE (darkcore_key_state_get_type ())
#define DARKCORE_KEY_STATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DARKCORE_TYPE_KEY_STATE, DarkcoreKeyState))
#define DARKCORE_KEY_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), DARKCORE_TYPE_KEY_STATE, DarkcoreKeyStateClass))
#define DARKCORE_IS_KEY_STATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DARKCORE_TYPE_KEY_STATE))
#define DARKCORE_IS_KEY_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), DARKCORE_TYPE_KEY_STATE))
#define DARKCORE_KEY_STATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), DARKCORE_TYPE_KEY_STATE, DarkcoreKeyStateClass))

typedef struct _DarkcoreKeyState DarkcoreKeyState;
typedef struct _DarkcoreKeyStateClass DarkcoreKeyStateClass;

struct _DarkcoreTexture {
	GObject parent_instance;
	DarkcoreTexturePrivate * priv;
	SDL_Surface* surface;
	GLuint texture;
	GLenum texture_format;
	gint nOfColors;
	GLsizei texture_id;
	gint loaded;
	gint width;
	gint height;
};

struct _DarkcoreTextureClass {
	GObjectClass parent_class;
};

typedef void (*DarkcoreEngineDelegateType) (DarkcoreEngine* world, void* user_data);
struct _DarkcoreEngine {
	GObject parent_instance;
	DarkcoreEnginePrivate * priv;
	DarkcoreEngineDelegateType on_loop_events_00;
	gpointer on_loop_events_00_target;
	GDestroyNotify on_loop_events_00_target_destroy_notify;
	DarkcoreEngineDelegateType on_loop_events_01;
	gpointer on_loop_events_01_target;
	GDestroyNotify on_loop_events_01_target_destroy_notify;
	DarkcoreEngineDelegateType on_loop_events_02;
	gpointer on_loop_events_02_target;
	GDestroyNotify on_loop_events_02_target_destroy_notify;
	DarkcoreEngineDelegateType on_loop_events_03;
	gpointer on_loop_events_03_target;
	GDestroyNotify on_loop_events_03_target_destroy_notify;
	DarkcoreEngineDelegateType on_loop_events_04;
	gpointer on_loop_events_04_target;
	GDestroyNotify on_loop_events_04_target_destroy_notify;
	GeeArrayList* textures;
	GeeArrayList* sprites;
	GLuint tids[32];
	DarkcoreKeyState* keys;
	DarkcoreSprite* player;
	SDL_Surface* screen;
	gboolean done;
	gint width;
	gint height;
};

struct _DarkcoreEngineClass {
	GObjectClass parent_class;
};


static gpointer darkcore_texture_parent_class = NULL;
extern GLuint darkcore_texture_inc;

GType darkcore_texture_get_type (void) G_GNUC_CONST;
enum  {
	DARKCORE_TEXTURE_DUMMY_PROPERTY
};
DarkcoreTexture* darkcore_texture_new (void);
DarkcoreTexture* darkcore_texture_construct (GType object_type);
GType darkcore_engine_get_type (void) G_GNUC_CONST;
DarkcoreTexture* darkcore_texture_new_from_file (const gchar* filename, DarkcoreEngine* world);
DarkcoreTexture* darkcore_texture_construct_from_file (GType object_type, const gchar* filename, DarkcoreEngine* world);
GType darkcore_sprite_get_type (void) G_GNUC_CONST;
GType darkcore_key_state_get_type (void) G_GNUC_CONST;
static void darkcore_texture_finalize (GObject* obj);


DarkcoreTexture* darkcore_texture_construct (GType object_type) {
	DarkcoreTexture * self = NULL;
	self = (DarkcoreTexture*) g_object_new (object_type, NULL);
	return self;
}


DarkcoreTexture* darkcore_texture_new (void) {
	return darkcore_texture_construct (DARKCORE_TYPE_TEXTURE);
}


DarkcoreTexture* darkcore_texture_construct_from_file (GType object_type, const gchar* filename, DarkcoreEngine* world) {
	DarkcoreTexture * self = NULL;
	SDL_Surface* _tmp0_ = NULL;
	g_return_val_if_fail (filename != NULL, NULL);
	g_return_val_if_fail (world != NULL, NULL);
	self = (DarkcoreTexture*) g_object_new (object_type, NULL);
	self->texture_id = (GLsizei) darkcore_texture_inc;
	darkcore_texture_inc = (GLuint) (darkcore_texture_inc + ((GLuint) 1));
	self->loaded = 0;
	_tmp0_ = IMG_Load (filename);
	self->surface = _tmp0_;
	if (self->surface == NULL) {
		const gchar* _tmp1_ = NULL;
		_tmp1_ = SDL_GetError ();
		g_print ("SDL Error: '%s'\n", _tmp1_);
	} else {
		SDL_SetAlpha (self->surface, (guint32) 0, (guchar) 0);
		self->width = self->surface->w;
		if ((self->surface->w & (self->surface->w - 1)) != 0) {
			g_print ("warning: image.bmp's width is not a power of 2\n");
		}
		self->height = self->surface->h;
		if ((self->surface->h & (self->surface->h - 1)) != 0) {
			g_print ("warning: image.bmp's height is not a power of 2\n");
		}
		self->nOfColors = (gint) self->surface->format->BytesPerPixel;
		if (self->nOfColors == 4) {
			if (self->surface->format->Rmask == 0x000000ff) {
				self->texture_format = GL_RGBA;
			} else {
				self->texture_format = GL_BGRA;
			}
		} else {
			if (self->nOfColors == 3) {
				if (self->surface->format->Rmask == 0x000000ff) {
					self->texture_format = GL_RGB;
				} else {
					self->texture_format = GL_BGR;
				}
			} else {
				g_print ("warning: the image is not truecolor..  this will probably break\n");
			}
		}
		glEnable (GL_TEXTURE_2D);
		glBindTexture (GL_TEXTURE_2D, world->tids[self->texture_id]);
		glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, (GLint) GL_NEAREST);
		glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, (GLint) GL_NEAREST);
		glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, (GLfloat) GL_REPEAT);
		glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, (GLfloat) GL_REPEAT);
		glTexImage2D (GL_TEXTURE_2D, (GLint) 0, (GLint) self->nOfColors, (GLsizei) self->surface->w, (GLsizei) self->surface->h, (GLint) 0, self->texture_format, GL_UNSIGNED_BYTE, self->surface->pixels);
		glDisable (GL_TEXTURE_2D);
		self->loaded = 1;
	}
	return self;
}


DarkcoreTexture* darkcore_texture_new_from_file (const gchar* filename, DarkcoreEngine* world) {
	return darkcore_texture_construct_from_file (DARKCORE_TYPE_TEXTURE, filename, world);
}


static void darkcore_texture_class_init (DarkcoreTextureClass * klass) {
	darkcore_texture_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = darkcore_texture_finalize;
}


static void darkcore_texture_instance_init (DarkcoreTexture * self) {
}


static void darkcore_texture_finalize (GObject* obj) {
	DarkcoreTexture * self;
	self = DARKCORE_TEXTURE (obj);
	G_OBJECT_CLASS (darkcore_texture_parent_class)->finalize (obj);
}


GType darkcore_texture_get_type (void) {
	static volatile gsize darkcore_texture_type_id__volatile = 0;
	if (g_once_init_enter (&darkcore_texture_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (DarkcoreTextureClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) darkcore_texture_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (DarkcoreTexture), 0, (GInstanceInitFunc) darkcore_texture_instance_init, NULL };
		GType darkcore_texture_type_id;
		darkcore_texture_type_id = g_type_register_static (G_TYPE_OBJECT, "DarkcoreTexture", &g_define_type_info, 0);
		g_once_init_leave (&darkcore_texture_type_id__volatile, darkcore_texture_type_id);
	}
	return darkcore_texture_type_id__volatile;
}



